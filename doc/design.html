<html>
<head>
<title>Places Design Documentation</title>
</head>

<body bgcolor=white>

<h2>Places Design Documentation</h2>
by John Mileham

<hr>

<!-- RETAINED FOR REFERENCE
<p>
<i>NOTE: Some of the sections of this template may not apply to your
package, e.g. there may be no user-visible UI elements for a component
of the ACS Core.  Furthermore, it may be easier in some circumstances
to join certain sections together, e.g. it may make sense to discuss
the data model and transactions API together instead of putting them
in separate sections.  And on occasion, you may find it easier to
structure the design discussion by the structure used in the
requirements document.  As this template is just a starting point, use
your own judgment, consult with peers when possible, and adapt
intelligently.</i>
</p>

<p>
<i>Also, bear in mind <b>the audience</b> for detailed design: fellow
programmers who want to maintain/extend the software, AND parties
interested in evaluating software quality. </i>
</p>

-->

<h3>I.  Essentials</h3>

<ul>
    <li> Places Tcl: packages/places/tcl/
         <ul>
             <li> <a href=/api-doc/procs-file-view?path=packages/places/tcl/address-procs.tcl>address-procs.tcl</a> <i>- provides address-related Tcl API</i> </li>
             <li> <a href=/api-doc/procs-file-view?path=packages/places/tcl/country-procs.tcl>country-procs.tcl</a> <i>- provides country-related Tcl API</i> </li>
             <li> <a href=/api-doc/procs-file-view?path=packages/places/tcl/postal_code-procs.tcl>postal_code-procs.tcl</a> <i>- provides postal-code-related Tcl API</i> </li>
             <li> <a href=/api-doc/procs-file-view?path=packages/places/tcl/state-procs.tcl>state-procs.tcl</a> <i>- provides state-related Tcl API</i> </li>
         </ul></li>
    <li> Places Data model: packages/places/sql/
         <ul>
             <li> <a href=/doc/sql/display-sql?url=places-create.sql&package_key=places>places-create.sql</a> <i>- wrapper for all component objects, packages and data model</i> </li>
             <li> <a href=/doc/sql/display-sql?url=places-core-create.sql&package_key=places>places-core-create.sql</a> <i>- provides the place object-type as well as subplace and location rels</i> </li>
             <li> <a href=/doc/sql/display-sql?url=country-create.sql&package_key=places>country-create.sql</a> <i>- defines the country place-type and PL/SQL API</i> </li>
             <li> <a href=/doc/sql/display-sql?url=region-create.sql&package_key=places>region-create.sql</a> <i>- defines the region place-type and PL/SQL API</i> </li>
             <li> <a href=/doc/sql/display-sql?url=us_state-create.sql&package_key=places>us_state-create.sql</a> <i>- defines the us_state place-type and PL/SQL API</i> </li>
             <li> <a href=/doc/sql/display-sql?url=postal_code-create.sql&package_key=places>postal_code-create.sql</a> <i>- defines the postal-code place-type and PL/SQL API</i> </li>
             <li> <a href=/doc/sql/display-sql?url=municipality-create.sql&package_key=places>municipality-create.sql</a> <i>- defines the municipality place-type and PL/SQL API</i> </li>
             <li> <a href=/doc/sql/display-sql?url=address-create.sql&package_key=places>address-create.sql</a> <i>- defines the address place-type and PL/SQL API</i> </li>
	     <li> <a href=/doc/sql/display-sql?url=countries-load.sql&package_key=places>countries-load.sql</a> <i>- provides full set of countries and their ISO codes.</i> </li>
	     <li> <a href=/doc/sql/display-sql?url=us_states-load.sql&package_key=places>us_states-load.sql</a> <i>- provides full set of US states and protectorates</i> </li>
	     <li> <a href=/doc/sql/display-sql?url=us_counties-load.sql&package_key=places>us_counties-load.sql</a> <i>- provides full set of US counties</i> </li>
	     <li> <a href=/doc/sql/display-sql?url=us_postal_codes-load.sql&package_key=places>us_postal_codes-load.sql</a> <i>- provides full set of US ZIP codes (which are stored as generic postal codes)</i> </li>

	 </ul></li>
    <p>
    <li> <a href=requirements>Places Requirements</a> </li>

<!-- MUST BE ADDED
    <li> ER diagram </li>
    <li> Transaction flow diagram </li>
-->

</ul>


<h3>II.  Introduction</h3>


<!-- RETAINED FOR REFERENCE
<p>
This section should provide an overview of the package
and address at least the following issues:
</p>

<ul>
    <li> What this package is intended to allow the user (or different
classes of users) to accomplish.  </li>

    <li> Within reasonable bounds, what this package is not intended to allow users to
accomplish. </li>

    <li> The application domains where this package is most likely to be of use.  </li>

    <li> A high-level overview of how the package meets its
    requirements (which should have been documented elsewhere).  This
    is to include relevant material from the "features" section of the
    cover sheet (the cover sheet is a wrapper doc with links to all
    other package docs). </li>
</ul>

<p>
Also worthy of treatment in this section:
</p>

<ul>
    <li> When applicable, a careful demarcation between the
    functionality of this package and others, which - at least
    superficially - appear to address the same requirements.  </li>
</ul>

<p>
Note: it's entirely possible that a discussion of what a package
is not intended to do differs from a discussion of future
improvements for the package.
</p>
-->

<p>
The Places service is intended to provide a general mechanism for
storing geographic information.  Any <b>place</b> may have a
latitude/longitude pair, which would allow radius searches based
on ZIP codes or any other place that carries a latitude/longitude
pair.  Places keeps track of various
different <b>place types</b>, and maintains their hierarchical
relationships independent of application logic (e.g. it knows that
Wisconsin isn't in Albania so that your application doesn't have
to).  The most interesting place type to most applications, however,
is the <b>address</b>, and its supporting PL/SQL and Tcl APIs.
Places allows an application to generate address entry and display
widgets, validate the integrity of user-defined addresses via a
standard <code>ad_page_contract</code> pluggable filter, insert
or update address values in the database without knowledge of the
underlying structure, and associate addresses with
application-specific objects.  Places ships (as of this writing) with a
complete set of <b>countries</b> (including ISO codes), US <b>states</b>
and protectorates (with USPS abbreviations), US <b>counties</b> and
US <b>ZIP codes</b> which can be used
to create widgets and provide parents for application-defined
places and place-types.
</p>

<p>
Most geographically-oriented applications should make use of the
Places service for storing their place data.  In addition to the
direct advantages of self-maintained place-containment integrity,
latitude/longitude support and out-of-the box country and state data,
geographic information that is stored via the Places service is
readily available to other applications and services that may
choose to extend the custom application or service in the future.
In cases where these benefits do not outweigh the value of a
very specific and highly-customized and/or tuned storage mechanism,
use of the Places service may be limited or foregone altogether.
</p>

<p>
Places will be immediately useful to applications such as Address
Book that will be able to use the <b>address</b> object without
worrying about what goes on under the hood.  Also, a geocentric
bboard application could tie into Places to define bboards for
specific regions, states, counties, zip codes, or any other place
type.
</p>

<p>
The Places service meets the need for a hierarchical storage
mechanism by providing a <b>place</b> subtype of <b>acs_object</b>,
which is subtyped by <b>country</b>, <b>region</b>, <b>us_county</b>,
<b>postal_code</b>, <b>municipality</b>, and <b>address</b>, and is
intended to be subtyped further by other applications.  <b>us_state</b>
is itself a subtype of <b>region</b>.  The hierarchy
is glued together using two relationships.  First is the <b>subplace</b>
relation.  This identifies a place as a component of another place.
A place may only be a direct component of one parent place
(e.g. Massachusetts may not belong to both Singapore and the United
States), but it is transitive, so an address that is defined in
Arkansas is understood to be within the United States.  The second
relationship is the <b>location</b> relation.  This associates an
object with a place.  It is transitive as well, so a geocentric
bboard entry with a location relationship to the state of Georgia
would also be related to the United States as a whole.  Places
also provides a more manageable address API by allowing application
programmers to define an address with a state and country in one step.
The API then verifies the hierarchy integrity and creates the
appropriate subplace relationship.  Also, views are provided to allow
application programmers to retrieve the state and country 
information without traversing the hierarchy.
</p>

<h3>III.  Historical Considerations</h3> 

<!-- RETAINED FOR REFERECE
<p>
For a given set of requirements, typically many possible
implementations and solutions exist.  Although eventually only one
solution is implemented, a discussion of the alternative solutions
canvassed - noting why they were rejected - proves helpful to both
current and future developers.  All readers would be reminded as to
why and how the particular solution developed over time, avoiding
re-analysis of problems already solved.
</p>
-->

<p>
</p>

<h3>IV.  Competitive Analysis</h3>

<!-- RETAINED FOR REFERENCE
<p>
Although currently only a few package documentation pages contain a
discussion of competing software, (e.g. chat, portals), this section
should be present whenever such competition exists.
</p>

<ul>
    <li>  If your package exhibits features missing from competing
software, this fact should be underscored.  </li>

    <li> If your package lacks features which are present in competing
software, the reasons for this should be discussed here; our sales
team needs to be ready for inquiries regarding features our software
lacks.  </li>
</ul>

<p>
Note that such a discussion may differ from a discussion of a
package's potential future improvements.
</p>
-->

<p>
</p>

<h3>V.  Design Tradeoffs</h3> 

<!--
<p>
No single design solution can optimize every desirable software
attribute. For example, an increase in the security of a system will
likely entail a decrease in its ease-of-use, and an increase in the
flexibility/generality of a system typically entails a decrease in the
simplicity and efficiency of that system. Thus a developer must decide
to put a higher value on some attributes over others: this section
should include a discussion of the tradeoffs involved with the design
chosen, and the reasons for your choices. Some areas of importance to
keep in mind are:
</p>

Areas of interest to users: 
<ul>
    <li> Performance: availability and efficiency  </li>
    <li> Flexibility  </li>
    <li> Interoperability  </li>
    <li> Reliability and robustness  </li>
    <li> Usability  </li>
</ul>

Areas of interest to developers:
<ul>
    <li> Maintainability </li> 
    <li> Portability </li>
    <li> Reusability </li>
    <li> Testability </li>
</ul>
<p>
-->

<p>
Aware that transitive relationships such as the <b>subplace</b> and
<b>location</b> relations would require expensive Oracle CONNECT BY
queries in a fully normalized implentation, we chose to follow the
methods of the already load-tested ACS parties mechanism.  All
relationships, both direct and indirect between places, subplaces
and other ACS objects are stored in a single trigger-maintained
index-organized table for very fast queries up and down the
place hierarchy.
</p>

<p>
This is a performance improvement relative to a standard hierarchy,
but it does lose a bit of speed relative to a non-hierarchical system.  One
comparison that could be made is to the ACS3.x <b>address-book</b> application.
Addresses in ACS3.x were represented in a single table, including
fields for state abbreviation and country ISO code, so a query like
"show me all the addresses in the state abbreviated as FL" could be posed without joining
with other tables to provide this information.  Under the Places service,
such a query would have to join against the index to retrieve that information.
In fact, there is a view provided in the Places service that makes this process
transparent, so an application can easily use Places in the same way that they
might have used an address-book entry under 3.x.
The extra join required is not actually as big a problem as it might seem.  If an implementation
of Places is discovered to lag on such queries, the addresses table itself
could be denormalized to provide this data in a flat representation.  We already provide an API
for creating addresses in what appears to the application to be
the flat ACS3.x style.  These API calls and the view mentioned earlier could be
adapted to maintain and use the denormalized City/State/Country information.
The result is that Places can have its cake and eat it too.  It maintains a hierarchical
representation of places in exchange for a little bit of insert and update overhead, something
that should be completely forgiveable in almost any implementation, as query speed would
almost certainly be the greater impediment to application performance.
</p>

<p>
Another major advantage of this system over ACS3.x, and in fact, most address storage
mechanisms from PDA address books to e-commerce sites is the capability for an
application or client site to define locale-specific place-types.  If you are building
an e-commerce site with international order fulfillment, this could be very useful.
Provinces of target countries could be loaded into the Places service, address widgets
could be templated to the new specifications, and a site could easily free itself from the
US-centric traditions of web development.  Places allows for creation of an arbitrary
hierarchy depth as well.  An address in Monaco doesn't need to belong in a region of the
country in order to highly geographically specific, so an address in Monaco could
belong directly to the country, where an address in the United States might want to
be a subplace of a region, a state, a county, a city and a zip code (note that most of
these place types are not defined by default, but could easily be added if the data were
provided).
</p>

<p>
The Places service provides very little end-user UI.  Only address entry widgets and
display widgets are provided.  Surprisingly, the biggest enhancement in user experience
over a flat address storage mechanism is provided by a system that provides no UI itself:
the address validation process.  When
an address is validated, it accepts fields for city, state, postal code, country etc.
Already if you select a state name from the dropdown without choosing a country, the
address will be placed in the appropriate country as well.  If a ZIP code database were loaded
into Places along with cities and a simple modification were made to the validation code,
a user could enter their one-line street address and ZIP code.  Places would do
the rest and put the address in the appropriate city, state and country.  Additionally,
if extra place types such as national segments were
defined in the hierarchy, the address could be referenced relative to those automatically,
making it possible for application programmers to, for example, generate targeted mailing
lists of users in the Southwestern US employing other application specific criteria such
as interests or income ranges.
</p>

<p>
From a programming standpoint, Places was designed for ease of application implementation
as well as the inherent robustness in a hierarchical model.  By providing straightforward SQL views, PL/SQL and
Tcl APIs, an application may store addresses, relate them to its objects, and display
the stored addresses without knowing or caring that an address is a complex hierarchical data structure.  At
the same time, another programmer can get down to the root of the
service and deal directly with the underlying structures for highly specific and
demanding applications.
</p>

<h3>VI.  API</h3> 

<!-- RETAINED FOR REFERENCE
<p>
Here's where you discuss the abstractions used by your package, such
as the procedures encapsulating the legal transactions on the data
model.  Explain the organization of procedures and their
particulars (detail above and beyond what is documented in the
code), including:
</p>

<ul>
    <li> Problem-domain components: key algorithms, e.g. a specialized
    statistics package would implement specific mathematical procedures. </li>

    <li> User-interface components: e.g. HTML widgets that the package may need.  </li>

    <li> Data management components: procedures that provide a stable
    interface to database objects and legal transactions - the latter
    often correspond to tasks. </li>
    
</ul>

<p>
Remember that the correctness, completeness, and stability of the API
and interface are what experienced members of our audience are looking
for.  This is a cultural shift for us at aD (as of mid-year 2000), in
that we've previously always looked at the data models as key, and
seldom spent much effort on the API (e.g. putting raw SQL in pages to
handle transactions, instead of encapsulating them via procedures).
Experience has taught us that we need to focus on the API for
maintainability of our systems in the face of constant change. 
</p>

<p>
Also noteworthy is that although the ACS currently utilizes the
AOLserver Tcl API, the current drive towards Java is likely to effect
a change in the content of these sections in the future.
</p>
-->
<ul>
    <li><h4><code>subplace_rel</code>: The Subplace Relation - <i>subtype of</i> <code>acs_rel</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
	             <li>Provides standard <code>new</code>/<code>delete</code> 
		         functionality.</li>
		     <li>Provides a <code>move</code> function that
		         takes a subplace's <code>place_id</code>, the 
			 <code>place_id</code> of
		         its original container, and a new container's <code>place_id</code>.
			 It returns the <code>rel_id</code> of the newly created relation.
			 This would be useful if an address was modified to be in
			 another zip code or state.</li>
		     <li>Provides a <code>violation</code> function that returns
		         null if <code>subplace_id</code> is either a
			 direct or indirect subplace of the place identified by <code>place_id</code>, otherwise
			 a meaningful error message.
			 This is used primarily by other validation processes.</li>
                 </ul>
	    </li>
	    <li> <h5>Views</h5>
	         <ul>
		      <li><code>place_element_map</code> - A mapping of all direct and indirect
		          place-subplace and place-locatee
		          relations.  This view is shared by <code>location_rel</code>, as data from
			  both relation types is displayed.</li>
	              <li><code>place_subplace_map</code> - A mapping of all direct and indirect
		          place-subplace relations.</li>
	         </ul>
	    </li>
	</ul>
    </li>
    <li><h4><code>location_rel</code>: The Location Relation - <i>subtype of</i> <code>acs_rel</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
	             <li>Provides standard <code>new</code>/<code>delete</code> 
		         functionality.  The <code>new</code> function does not allow
			 the application access to the value of <code>sort_key</code>,
			 however.  Sort key integrity is maintained by the relation itself.
			 To insert a <code>location_rel</code> before another relation pertaining to the
			 same <code>acs_object</code>, you simply enter a <code>before_rel_id</code>
			 parameter.  If <code>before_rel_id</code> is not specified, the relationship
			 is assigned a sort_key higher than all the others pertaining to the same
			 object.  The <code>use_context</code> parameter exists to allow
			 applications to define textual keys to determine the function that
			 the relationship serves.  A typical <code>use_context</code> might
			 be <code>'mailing'</code> for a mailing address associated with an
			 order in an e-commerce application.</li>
		     <li>Provides a <code>move</code> function that
		         takes a locatee's <code>locatee_id</code>, the 
			 <code>place_id</code> of
		         its original location, and a new location's <code>place_id</code>.
			 It returns the <code>rel_id</code> of the newly created relation.
			 This would be useful if an object were to change locations, such as
			 an office relocating. 

	             <li>Because the application is not expected to interact with <code>sort_key</code>
		         itself, there is a <code>swap_sort</code> procedure, which allows any two
			 relations pertaining to the same object to be swapped in terms of sort
			 order.</li>
                 </ul>
	    </li>
	    <li> <h5>Views</h5>
	         <ul>
		      <li><code>place_element_map</code> - A mapping of all direct and indirect
		          place-subplace and place-locatee
		          relations.  This view is shared by <code>subplace_rel</code>, as data from
			  both relation types is displayed.</li>
	              <li><code>place_locatee_map</code> - A mapping of all direct and indirect
		          place-locatee relations.</li>
	         </ul>
	    </li>
	</ul>
    </li>
    <li><h4><code>place</code>: Place Object-type - <i>subtype of</i> <code>acs_object</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
		      <li>Provides standard <code>new</code>/<code>delete</code> functionality.
		          The new function adds the ability to create a place
			  as a subplace of another place in a single step by taking
			  <code>superplace_id</code> as an optional argument.  This works by intrinsically
			  calling <code>subplace_rel.new</code> after creating the place.  Also,
			  a place may be created and associated with an <code>acs_object</code>
			  in a single step, as the <code>new</code> function also takes an
			  optional <code>locatee_id</code> along with the optional fields associated
			  with that relationship (<code>use_context</code> and <code>before_rel_id</code>).</li>
		 </ul>
	    </li>
	</ul>
    </li>
    <li><h4><code>country</code>: Country Object-type - <i>subtype of</i> <code>place</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
		      <li>Provides <code>new</code>/<code>delete</code> functionality as
		          extended by the <code>place</code> object.</li>
		      <li>Provides a standard <code>name</code> function.</li>
		 </ul>
	    </li>
	    <li> <h5>Tcl API</h5>
	         <ul>
		      <li><a href=/api-doc/proc-view?proc=place%3a%3acountry%3a%3aiso>place::country::iso</a> is
		          provided to allow an application to easily look up the ISO of a country with a given <code>country_id</code>
		      <li><a href=/api-doc/proc-view?proc=place%3a%3acountry%3a%3aname>place::country::name</a> is
		          provided to allow an application to easily look up the name of a country with
			  a given <code>country_id</code>.</li>
		      <li><a href=/api-doc/proc-view?proc=place%3a%3acountry%3a%3aselect>place::country::select</a> is
		          provided to generate a country selection widget containing all the countries in the world.</li>
                 </ul>
            </li>
	</ul>
    </li>
    <li><h4><code>region</code>: Region Object-type - <i>subtype of</i> <code>place</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
		      <li>Provides <code>new</code>/<code>delete</code> functionality as
		          extended by the <code>place</code> object.</li>
		      <li>Provides a standard <code>name</code> function.</li>
		 </ul>
	    </li>
	</ul>
    </li>
    <li><h4><code>us_state</code>: US State Object-type - <i>subtype of</i> <code>region</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
		      <li>Provides <code>new</code>/<code>delete</code> functionality as
		          extended by the <code>region</code> object.</li>
		      <li>Provides a standard <code>name</code> function.</li>
		 </ul>
	    </li>
	    <li> <h5>Tcl API</h5>
	         <ul>
		      <li><a href=/api-doc/proc-view?proc=place%3a%3astate%3a%3aname>place::state::name</a> is
		          provided to allow an application to easily look up the name of a state with
			  a given <code>state_id</code>.</li>
		      <li><a href=/api-doc/proc-view?proc=place%3a%3astate%3a%3aselect>place::state::select</a> is
		          provided to generate a state selection widget containing all US states.</li>
		      <li><a href=/api-doc/proc-view?proc=place%3a%3astate%3a%3ausps_abbrev>place::state::usps_abbrev</a> is
		          provided to allow an application to easily look up the USPS abbrev of a state with a given
			  <code>state_id</code>.</li>
                 </ul>
            </li>
	</ul>
    </li>
    <li><h4><code>us_county</code>: US County Object-type - <i>subtype of</i> <code>place</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
		      <li>Provides <code>new</code>/<code>delete</code> functionality as
		          extended by the <code>place</code> object.</li>
		      <li>Provides a standard <code>name</code> function.</li>
		 </ul>
	    </li>
        </ul>
    </li>
    <li><h4><code>postal_code</code>: Postal Code Object-type - <i>subtype of</i> <code>place</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
		      <li>Provides <code>new</code>/<code>delete</code> functionality as
		          extended by the <code>place</code> object.</li>
		      <li>Provides a standard <code>name</code> function.</li>
		 </ul>
	    </li>
	    <li> <h5>Tcl API</h5>
	         <ul>
		      <li><a href=/api-doc/proc-view?proc=place%3a%3apostal_code%3a%3apostal_code>place::postal_code::postal_code</a> is
		          provided to allow an application to easily look up the postal code of
			  a given <code>postal_code_id</code>.</li>
		      <li><a href=/api-doc/proc-view?proc=place%3a%3apostal_code%3a%3apostal_code_id>place::postal_code::postal_code_id</a> is
		          provided to allow an application to easily look up the <code>postal_code_id</code> of
			  a given postal code.</li>
                 </ul>
            </li>
        </ul>
    </li>
    <li><h4><code>municipality</code>: Municipality Object-type - <i>subtype of</i> <code>place</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
		      <li>Provides <code>new</code>/<code>delete</code> functionality as
		          extended by the <code>place</code> object.</li>
		      <li>Provides a standard <code>name</code> function.</li>
		 </ul>
	    </li>
        </ul>
    </li>
    <li><h4><code>address</code>: Address Object-type - <i>subtype of</i> <code>place</code></h4>
        <ul>
            <li> <h5>PL/SQL API</h5>
	         <ul>
		      <li>Provides <code>new</code>/<code>delete</code> functionality as
		          extended by the <code>place</code> object.</li>
		      <li>Provides a standard <code>name</code> function.</li>
		      <li>Provides a <code>violation</code> function that returns a textual error message
		          if the address described is invalid, or null if everything is ok.</li>
		      <li>Provides a <code>smallest_superplace_id</code> function that returns
		          the <code>place_id</code> of the smallest valid superplace.  This function is
			  used by the <code>new_intl</code> function to determine what superplace to put the
			  newly generated address into.</li>
		      <li>Provides a <code>new_intl</code> function that acts similarly to the
		          <code>new</code> function, except that it takes optional <code>postal_code_id</code>,
			  <code>region_id</code> and
			  <code>country_id</code> codes instead of a superplace_id for automatic validation and
			  placement on the place hierarchy.</li>
		      <li>Provides an <code>update_intl</code> procedure to update an address entry.  This does
		          hierarchy validation and makes <code>subplace_rel.move</code> calls as appropriate.</li>
		 </ul>
	    </li>
	    <li> <h5>Tcl API</h5>
	         <ul>
		      <li> Retrieval:
		           <ul>
			       <li><a href=/api-doc/proc-view?proc=place%3a%3aaddress%3a%3a1row>place::address::1row</a></li>
		               <li><a href=/api-doc/proc-view?proc=place%3a%3aaddress%3a%3amultirow>place::address::multirow</a></li>
			   </ul>
                      </li>
		      <li> Display:
		           <ul>
		               <li><a href=/api-doc/proc-view?proc=place%3a%3aaddress%3a%3adisplaywidget>place::address::displaywidget</a></li>
		           </ul>
                      </li>
		      <li> Entry:
		           <ul>
			        <li><a href=/api-doc/proc-view?proc=place%3a%3aaddress%3a%3aentry1row>place::address::entry1row</a></li>
				<li><a href=/api-doc/proc-view?proc=place%3a%3aaddress%3a%3aentrywidget>place::address::entrywidget</a></li>
		           </ul>
		      </li>
		      <li> Validation:
		           <ul>
			        <li><a href=/api-doc/proc-view?proc=place%3a%3aaddress%3a%3aviolation>place::address::violation</a></li>
				<li><a href=/api-doc/proc-view?proc=ad%5fpage%5fcontract%5ffilter%5fproc%5faddress>The <code>ad_page_contract</code> <code>address</code> filter</a></li>
		           </ul>
		      </li>
		      <li> Manipulation:
		           <ul>
			        <li><a href=/api-doc/proc-view?proc=place%3a%3aaddress%3a%3ainsert>place::address::insert</a></li>
				<li><a href=/api-doc/proc-view?proc=place%3a%3aaddress%3a%3aupdate>place::address::update</a></li>
			   </ul>
		      </li>
                 </ul>
            </li>
	    <li> <h5>Views</h5>
	         <ul>
		      <li><code>addresses_complete</code> - A flat view of all addresses in the database providing
		          state abbreviations and country ISO codes as if they were part of the table itself.</li>
	              <li><code>addresses_located</code> - A wrapper around <code>addresses_complete</code> that
		          returns all addresses that serve as locations, along with the objects to which they are related
			  and the relationships' <code>use_context</code> and <code>sort_key</code> values.</li>
	         </ul>
	    </li>
	</ul>
    </li>
</ul>

<h3>VII.  Data Model Discussion</h3>

<!--
<p>
The data model discussion should do more than merely display the SQL
code, since this information is already be available via a link in the
"essentials" section above.  Instead, there should be a high-level
discussion of how your data model meets your solution requirements:
why the database entities were defined as they are, and what
transactions you expect to occur. (There may be some overlap with the
API section.)  Here are some starting points:
</p>

<ul>
    <li> The data model discussion should address the intended usage
of each entity (table, trigger, view, procedure, etc.) when this
information is not obvious from an inspection of the data model
itself. </li>

    <li> If a core service or other subsystem is being used (e.g., the
new parties and groups, permissions, etc.) this should also be
mentioned. </li>

    <li> Any default permissions should be identified herein.  </li>

    <li> Discuss any data model extensions which tie into other
    packages.  </li>

    <h4>Transactions</h4>

    <li> Discuss modifications which the database may undergo from
    your package. Consider grouping legal transactions according to
    the invoking user class, i.e. transactions by an ACS-admin, by
    subsite-admin, by a user, by a developer, etc.  </li>

</ul>
-->

<p>
The Places service was designed with programmer efficiency in mind, and as
such, most legal transactions may be performed using the PL/SQL and Tcl
API calls detailed above.  Places is a fundamental service, and
leaves permissioning (including security context, etc) to the application
programmer.  Any operation on the tables defined in <code>places-create.sql</code>
is legal, with the exception of updates on the <code>subplace_rels</code>,
<code>location_rels</code> and any operation (insert, update or delete) on 
<code>place_element_index</code>.  Much like the <code>groups</code> data model,
a trigger-maintained index of the hierarchy that they define must be kept.  The
triggers would be inordinately complex for an update operation, and the insert and
delete triggers certainly
wouldn't take kindly to manual alteration of the index.  Also, with the API
provided, there should be no need to modify the <code>sort_key</code> column of
the <code>location_rels</code> table.  If your application chooses to do so, please
be careful to follow the tenets of ACID (you can leave the durability part
to Oracle, but it would be remarkably easy to fall short on atomicity, consistency
and isolation).  In short, all transactions
that make sense in the context of your application that may be safely carried out
relative to the places service and its other dependent applications are legal.
</p>

<h3>VIII.  User Interface</h3>

<!--
<p>
In this section, discuss user interface issues and pages to be built;
you can organize by the expected classes of users.  These may include:
</p>

<ul>
    <li> Developers
    <li> ACS administrators (previously known as site-wide administrators)
    <li> Subsite administrators
    <li> End users
</ul>

<p>
You may want to include page mockups, site-maps, or other visual aids.
Ideally this section is informed by some prototyping you've done, to
establish the package's usability with the client and other interested
parties.
</p>

<p>
<i>Note: In order that developer documentation be uniform across
different system documents, these users should herein be designated as
"the developer," "the ACS-admin," "the sub-admin," and "the user,"
respectively. </i>
</p>

<p>
Finally, note that as our templating system becomes more entrenched
within the ACS, this section's details are likely to shift from UI
specifics to template interface specifics.
</p>
-->

<p>
Only state, country and address widgets are provided directly by Places.
The Places service relies on application programmers to make appropriate
use of the widgets provided.
</p>

<h3>IX.  Configuration/Parameters</h3>

<p>
Places requires no special configuration.
</p>

<h3>X.  Future Improvements/Areas of Likely Change</h3>

<ul>
     <li>US postal service abbreviations of states will likely be trickled up to the region as a regional_ps_abbrev to promote i18n.</li>
     <li>Multirow address display, entry, validation and manipulation API will likely be provided.</li>
     <li>Radius search API that addresses the issues involved in internationalized geographic radius searches.</li>
</ul>

<h3>XI.  Authors</h3>

<ul>
    <li> Original concept and ACS3.x prototype: Yonatan Feldman &lt;<a href=yon@arsdigita.com>yon@arsdigita.com</a>&gt;
    <li> System creator: John Mileham &lt;<a href=jmileham@arsdigita.com>jmileham@arsdigita.com</a>&gt;
    <li> System owner: John Mileham &lt;<a href=jmileham@arsdigita.com>jmileham@arsdigita.com</a>&gt;
    <li> Documentation author: John Mileham &lt;<a href=jmileham@arsdigita.com>jmileham@arsdigita.com</a>&gt;
</ul>


<h3>XII.  Revision History</h3>


<table cellpadding=2 cellspacing=2 width=90% bgcolor=#efefef>
<tr bgcolor=#e0e0e0>
    <th width=10%>Document Revision #</th>
    <th width=50%>Action Taken, Notes</th>
    <th>When?</th>
    <th>By Whom?</th>
</tr>

<tr>
   <td>0.1</td>
   <td>Creation</td>
   <td>12/15/2000</td>
   <td>John Mileham</td>
</tr>

<tr>
   <td>0.2</td>
   <td>Revised and overhauled for Places alpha2 release</td>
   <td>12/15/2000</td>
   <td>John Mileham</td>
</tr>

</table>

<p>

<hr>

<a href="mailto:jmileham@arsdigita.com">jmileham@arsdigita.com</a>

</body>
</html>
